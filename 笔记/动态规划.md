[TOC]

# 动态规划

## 定义与约定

+ 动态规划（简称DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
+ 适用范围：有**重叠子问题**和**最优子结构**性质的问题。
+ 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。
+ 许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。
+ 动态规划是通过**拆分问题，**定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。
+ **如何拆分问题**，才是动态规划的核心。这靠的是**状态的定义**和**状态转移方程的定义**。

## 适用范围

1. **最优子结构性质**。如果**问题的最优解所包含的子问题的解也是最优的**，我们就称该问题具有最优子结构性质。它为动态规划算法解决问题提供了重要线索。
2. **无后效性**。即**子问题的解（称之为状态）一旦确定，就不再改变**，不受在这之后、包含它的更大的问题的求解决策影响。
3. **子问题重叠**。指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，**有些子问题会被重复计算多次**
4. 前两点是能够动态规划的必要的条件，如果不是一定要最优解的话第一点可以稍作妥协，第三点不是必要条件，但却是动态规划能否高效的核心

## 求解的基本步骤

 	动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。

1. **划分阶段**：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的**阶段一定要是有序的或者是可排序的**，否则问题就无法求解。

2. **确定状态和状态变量**：将问题发展到各个阶段时所处于的各种客观情况**用不同的状态（子问题）表示出来**。当然，状态的选择要满足无后效性。

3. **确定决策并写出状态转移方程**：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。

4. **寻找边界条件**：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

   一般，只要**解决问题的阶段、状态和状态转移决策**确定了，就可以写出**状态转移方程**（包括边界条件）。

   实际应用中可以按以下几个简化的步骤进行设计：

   1. 分析最优解的性质，并刻画其结构特征。
   2. 递归的定义最优解。
   3. 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
   4. 根据计算最优值时得到的信息，构造问题的最优解

## 问题举例

### 最长非降子序列的长度

#### 题目

一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度

#### 算法分析

##### 分割问题

​	我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i<N， 那么上面的问题变成了原问题的一个子问题 

##### 定义状态

然后我们定义d(i)=前i个数中以A[i]结尾的最长非降子序列的长度。这个d(i)就是我们要找的**状态**。如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。

##### 状态转移

+ 我们约定最长非降子序列用LIS表示
+ 假如有一下序列： 5，3，4，8，6，7
+ 根据上面找到的状态，我们可以得到：
  + 前1个数的LIS长度d(1)=1(序列：`5`)
  + 前2个数的LIS长度d(2)=1(序列：`3`    3前面没有比3小的)
  + 前3个数的LIS长度d(3)=2(序列：`3，4`  4前面有个比它小的3，所以$d(3)=d(2)+1)$
  + 前4个数的LIS长度d(4)=3(序列：`3，4，8` 8前面比它小的有3个数，所以$d(4)=max[d(1),d(2),d(3)]+1=3)$

OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到：

$$d(i) = max[1, d(j)+1],其中j<i,A[j]<=A[i]$$

用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。

#### 代码

```c++
#include <iostream>
using namespace std;
const int maxN = 100;

int main(){
    int n;
    int maxLen=0;
    cin >> n;
    int a[maxN];
    int maxSubNum[maxN];
    for(int i=0; i<n; i++){
        cin >> a[i];
    }

    for(int i=0; i<n; i++){
        maxSubNum[i]=1; // 至少有一个是它自己
        for(int j=0; j<i; j++){
            if(a[i]>a[j]&&maxSubNum[i]<maxSubNum[j]+1){ // maxSubNum[i]<maxSubNum[j]+1很关键的条件，动态问题 
                maxSubNum[i] = maxSubNum[j]+1;
            }
        }
        if(maxSubNum[i] > maxLen){
            maxLen = maxSubNum[i];
        }
    }
    cout << maxLen << endl;
    return 0;
}
```

